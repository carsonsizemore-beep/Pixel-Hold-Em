<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tiny Voxel Kingdom</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        :root {
            --bg-dark: rgba(20, 24, 36, 0.9);
            --bg-darker: rgba(10, 12, 18, 0.95);
            --accent-gold: #FFD700;
            --text-light: #ecf0f1;
            --border-radius: 8px;
            --border-light: 1px solid rgba(255, 255, 255, 0.15);
            --accent-danger: #e53935;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB; /* Initial Sky Blue */
            font-family: 'Press Start 2P', monospace; /* Pixel font */
            user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
        }

        /* HUD - Resources */
        #resources {
            display: flex;
            gap: 30px;
            padding: 12px 30px;
            background: var(--bg-dark);
            color: var(--text-light);
            font-size: 12px;
            backdrop-filter: blur(8px);
            pointer-events: auto;
            border-bottom: 2px solid rgba(255, 215, 0, 0.3);
            border-bottom-left-radius: 16px;
            border-bottom-right-radius: 16px;
            align-self: center; /* Center top */
            margin-top: 0;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            transition: all 0.3s ease;
        }

        .res-item {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .res-icon {
            width: 14px;
            height: 14px;
            border-radius: 2px;
            box-shadow: 0 0 8px rgba(255,255,255,0.3);
        }

        /* Selection Menu */
        #selection-menu {
            position: absolute;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-darker);
            border: 1px solid var(--accent-gold);
            border-radius: 12px;
            padding: 10px;
            display: none; /* Hidden by default */
            flex-direction: row;
            gap: 10px;
            pointer-events: auto;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            z-index: 20;
        }
        
        #selection-menu.active {
            display: flex;
            animation: popIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .sel-btn {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 10px 15px;
            border-radius: 6px;
            font-family: inherit;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.1s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .sel-btn:hover {
            background: rgba(255,255,255,0.15);
            transform: translateY(-2px);
        }

        .sel-btn.danger {
            border-color: var(--accent-danger);
            color: #ff8a80;
        }
        .sel-btn.danger:hover {
            background: rgba(229, 57, 53, 0.2);
        }

        @keyframes popIn {
            from { transform: translateX(-50%) scale(0.8); opacity: 0; }
            to { transform: translateX(-50%) scale(1); opacity: 1; }
        }

        /* Build Bar (New Design) */
        #build-bar-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: auto;
            gap: 5px;
            transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
        }

        #build-bar-container.minimized {
            transform: translateX(-50%) translateY(calc(100% - 20px)); /* Hide mostly */
        }

        /* Minimize Handle */
        #minimize-handle {
            width: 40px;
            height: 20px;
            background: var(--bg-dark);
            border: var(--border-light);
            border-bottom: none;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            text-align: center;
            line-height: 20px;
            font-size: 10px;
            color: #aaa;
            cursor: pointer;
            transition: background 0.2s;
        }
        #minimize-handle:hover {
            background: rgba(255,255,255,0.1);
            color: white;
        }

        #toolbar {
            display: flex;
            gap: 8px;
            padding: 10px;
            background: var(--bg-dark);
            border: var(--border-light);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        }

        .tool-btn {
            width: 64px;
            height: 74px;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 6px 2px;
            font-family: inherit;
            color: #ccc;
            transition: all 0.1s;
            position: relative;
        }

        .tool-btn:hover {
            background: rgba(255,255,255,0.1);
            transform: translateY(-4px);
            border-color: rgba(255,255,255,0.3);
        }

        .tool-btn:active {
            transform: translateY(2px);
        }

        .tool-btn.active {
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid var(--accent-gold);
            color: var(--accent-gold);
            transform: translateY(-6px);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
            z-index: 10;
        }

        .tool-icon {
            width: 24px;
            height: 24px;
            background-size: contain;
            background-repeat: no-repeat;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            margin-top: 4px;
        }

        .tool-name {
            font-size: 8px;
            margin-top: 4px;
            font-weight: bold;
        }

        .cost-tooltip {
            font-size: 7px;
            color: #888;
            margin-top: 2px;
        }
        
        .tool-btn.active .cost-tooltip {
            color: #ffe082;
        }

        .hotkey-indicator {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 8px;
            color: rgba(255,255,255,0.4);
        }
        .tool-btn.active .hotkey-indicator {
            color: var(--accent-gold);
        }

        /* Start Modal */
        #modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }

        #modal-content {
            background: var(--bg-dark);
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            border: 1px solid var(--accent-gold);
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.1);
            max-width: 450px;
            color: white;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 20px;
            color: var(--accent-gold);
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            line-height: 1.5;
        }

        p {
            font-size: 10px;
            color: #aaa;
            margin-bottom: 30px;
            line-height: 2;
        }

        button.start-btn {
            background: linear-gradient(to bottom, #4CAF50, #2E7D32);
            color: white;
            border: none;
            padding: 15px 40px;
            font-family: inherit;
            font-size: 12px;
            cursor: pointer;
            border-radius: 8px;
            box-shadow: 0 4px 0 #1B5E20;
            transition: transform 0.1s;
        }
        
        button.start-btn:active {
            transform: translateY(4px);
            box-shadow: none;
        }

        /* Notifications */
        #notifications {
            position: absolute;
            top: 100px;
            right: 20px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
            pointer-events: none;
        }

        .toast {
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 10px;
            animation: fadeOut 3s forwards;
            border-left: 3px solid var(--accent-gold);
            backdrop-filter: blur(4px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        @keyframes fadeOut {
            0% { opacity: 0; transform: translateX(20px); }
            10% { opacity: 1; transform: translateX(0); }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* Tutorial controls help */
        #controls-help {
            position: absolute;
            bottom: 30px;
            left: 20px;
            max-width: 220px;
            color: rgba(255,255,255,0.6);
            font-size: 9px;
            background: rgba(0,0,0,0.4);
            padding: 15px;
            border-radius: 8px;
            pointer-events: auto; /* Allow clicking close button */
            line-height: 1.6;
            backdrop-filter: blur(2px);
        }

        #controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            color: var(--accent-gold);
            font-weight: bold;
        }

        #close-controls {
            cursor: pointer;
            color: #aaa;
            font-size: 12px;
        }
        #close-controls:hover {
            color: white;
        }

        /* Time Indicator */
        #time-display {
            position: absolute;
            top: 20px;
            left: 20px;
            background: var(--bg-dark);
            color: var(--accent-gold);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 10px;
            pointer-events: none;
            border: 1px solid rgba(255,255,255,0.1);
        }

        /* Control Buttons Group */
        .control-btn {
            background: var(--bg-dark);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 10px;
            border-radius: 8px;
            font-family: inherit;
            font-size: 12px;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .control-btn:hover {
            background: rgba(255, 215, 0, 0.2);
            border-color: var(--accent-gold);
        }
        .control-btn.active {
            background: var(--accent-gold);
            color: black;
        }

        /* Speed Button */
        #speed-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: auto;
            min-width: 40px;
            padding: 10px 15px;
        }

        /* Pause Button */
        #pause-btn {
            position: absolute;
            top: 20px;
            right: 70px;
            width: 35px;
            height: 35px;
        }

        /* Mute Button */
        #mute-btn {
            position: absolute;
            top: 20px;
            right: 115px;
            width: 35px;
            height: 35px;
        }

        /* New Day Announcement */
        #day-announcement {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
            color: var(--accent-gold);
            text-shadow: 0 4px 20px rgba(0,0,0,0.8);
            pointer-events: none;
            opacity: 0;
            transition: opacity 1s ease-in-out;
            z-index: 50;
            text-align: center;
            width: 100%;
        }

        #day-announcement.visible {
            opacity: 1;
        }

    </style>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="time-display">Day 1</div>
        <button id="speed-btn" class="control-btn" onclick="toggleSpeed()">x1</button>
        <button id="pause-btn" class="control-btn" onclick="togglePause()">‚è∏</button>
        <button id="mute-btn" class="control-btn" onclick="SoundManager.toggleMute()">üîä</button>

        <div id="day-announcement">Day 1</div>

        <!-- Top Resource Bar -->
        <div id="resources">
            <div class="res-item" title="Gold">
                <div class="res-icon" style="background:#FFD700"></div>
                <span id="res-gold">100</span>
            </div>
            <div class="res-item" title="Wood">
                <div class="res-icon" style="background:#8B4513"></div>
                <span id="res-wood">50</span>
            </div>
            <div class="res-item" title="Stone">
                <div class="res-icon" style="background:#808080"></div>
                <span id="res-stone">20</span>
            </div>
            <div class="res-item" title="Population">
                <div class="res-icon" style="background:#FF69B4"></div>
                <span id="res-pop">0 / 0</span>
            </div>
        </div>

        <!-- Notification Area -->
        <div id="notifications"></div>

        <!-- Selection Menu -->
        <div id="selection-menu">
            <button class="sel-btn" onclick="rotateSelection()">Rotate</button>
            <button class="sel-btn danger" onclick="demolishSelection()">Demolish</button>
            <button class="sel-btn" onclick="clearSelection()">X</button>
        </div>

        <div id="controls-help">
            <div id="controls-header">
                <span>CONTROLS</span>
                <span id="close-controls" onclick="document.getElementById('controls-help').style.display='none'">X</span>
            </div>
            [1-7]: Select Building<br>
            Left Click: Build / Select<br>
            Right Click: Quick Remove<br>
            Shift + Left Click: Upgrade Tower (500G)<br>
            Middle Click: Pan Camera<br>
            Scroll Wheel: Zoom<br>
            Shift + Middle Click: Rotate Camera
        </div>

        <!-- Build Bar -->
        <div id="build-bar-container">
            <div id="minimize-handle" onclick="toggleBuildWindow()">‚ñº</div>
            <div id="toolbar">
                <div class="tool-btn active" onclick="selectTool('wall')" id="btn-wall">
                    <span class="hotkey-indicator">1</span>
                    <div class="tool-icon" style="background-color:#757575"></div>
                    <span class="tool-name">Wall</span>
                    <div class="cost-tooltip">5 Stone</div>
                </div>
                <div class="tool-btn" onclick="selectTool('house')" id="btn-house">
                    <span class="hotkey-indicator">2</span>
                    <div class="tool-icon" style="background-color:#d32f2f"></div>
                    <span class="tool-name">House</span>
                    <div class="cost-tooltip">60 Wood</div>
                </div>
                <div class="tool-btn" onclick="selectTool('farm')" id="btn-farm">
                    <span class="hotkey-indicator">3</span>
                    <div class="tool-icon" style="background-color:#F0E68C"></div>
                    <span class="tool-name">Farm</span>
                    <div class="cost-tooltip">30 Wood</div>
                </div>
                <div class="tool-btn" onclick="selectTool('lumber')" id="btn-lumber">
                    <span class="hotkey-indicator">4</span>
                    <div class="tool-icon" style="background-color:#228B22"></div>
                    <span class="tool-name">Woodcut</span>
                    <div class="cost-tooltip">50 Wood</div>
                </div>
                 <div class="tool-btn" onclick="selectTool('mine')" id="btn-mine">
                    <span class="hotkey-indicator">5</span>
                    <div class="tool-icon" style="background-color:#555555"></div>
                    <span class="tool-name">Mine</span>
                    <div class="cost-tooltip">50 Gold</div>
                </div>
                <div class="tool-btn" onclick="selectTool('tower')" id="btn-tower">
                    <span class="hotkey-indicator">6</span>
                    <div class="tool-icon" style="background-color:#607D8B"></div>
                    <span class="tool-name">Tower</span>
                    <div class="cost-tooltip">100 Stone</div>
                </div>
                <div class="tool-btn" onclick="selectTool('campfire')" id="btn-campfire">
                    <span class="hotkey-indicator">7</span>
                    <div class="tool-icon" style="background-color:#FF4500"></div>
                    <span class="tool-name">Campfire</span>
                    <div class="cost-tooltip">50 Gold</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Start Screen Modal -->
    <div id="modal-overlay">
        <div id="modal-content">
            <h1>TINY VOXEL KINGDOM</h1>
            <p>Welcome, Architect.<br><br>The sun rises and sets on your empire.<br>Gather by day, defend by night.<br>Build Walls and Towers to protect against the night horde.</p>
            <button class="start-btn" onclick="startGame()">START BUILDING</button>
        </div>
    </div>

    <script>
        // --- Game Configuration & State ---
        const GRID_SIZE = 20;
        const TILE_SIZE = 10;
        
        const RESOURCES = {
            gold: 0,
            wood: 0,
            stone: 0,
            pop: 0,
            popCap: 0
        };

        const BUILDING_TYPES = {
            wall:   { name: 'Wall',   cost: { gold: 0, wood: 0, stone: 5 },   type: 'wall', hp: 200 },
            house:  { name: 'House',  cost: { gold: 0, wood: 60, stone: 0 },  type: 'residential', cap: 4, tax: 0, hp: 100 },
            farm:   { name: 'Farm',   cost: { gold: 0, wood: 30, stone: 0 },  type: 'economy', income: 5, hp: 50 },
            lumber: { name: 'Woodcut',cost: { gold: 0, wood: 50, stone: 0 },  type: 'resource', resource: 'wood', amount: 3, hp: 80 },
            mine:   { name: 'Mine',   cost: { gold: 50, wood: 0, stone: 0 }, type: 'resource', resource: 'stone', amount: 3, hp: 150 }, 
            tower:  { name: 'Tower',  cost: { gold: 0, wood: 0, stone: 100 },  type: 'defense', cap: 0, hp: 300 },
            // FIXED: Added tower_lvl2 to BUILDING_TYPES to prevent crash when invaders attack upgraded towers
            tower_lvl2: { name: 'Tower Lvl 2', cost: { gold: 0, wood: 0, stone: 0 }, type: 'defense', cap: 0, hp: 600 },
            campfire: { name: 'Campfire', cost: { gold: 50, wood: 0, stone: 0 }, type: 'decoration', hp: 20 },
            // Nature Items
            tree:   { name: 'Tree',   cost: { gold: 20, wood: 0, stone: 0 },  type: 'nature' },
            bush:   { name: 'Bush',   cost: { gold: 10, wood: 0, stone: 0 },  type: 'nature' },
            rock:   { name: 'Rock',   cost: { gold: 20, wood: 0, stone: 0 },  type: 'nature' }
        };

        let currentTool = 'wall';
        let gameGrid = {}; // key: "x,z", value: { type, mesh, data: {} }
        let selectedBuildingKey = null;
        let isGameActive = false;
        let isPaused = false;
        let lastTime = 0;
        let economyTimer = 0;
        let farmerPayTimer = 0;
        let minePayTimer = 0;
        let lumberPayTimer = 0; 
        let wageTimer = 0;
        let natureTimer = 0;
        let invaderSpawnTimer = 0;
        let homelessTimer = 0;
        let homelessStart = 0;

        // Day/Night Cycle Variables
        let dayTime = 0; // 0 to 1 range
        const DAY_DURATION = 360000; // 6 minutes (3m day, 3m night)
        const GUARD_DURATION = DAY_DURATION; // Full cycle
        let isDayTime = true;
        let timeScale = 1.0;

        let dayCount = 1;
        let sunLight, ambientLight;

        // --- Audio System ---
        const SoundManager = {
            ctx: null,
            isMuted: false,
            bgmInterval: null,
            
            init: function() {
                if (!this.ctx) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (AudioContext) {
                        this.ctx = new AudioContext();
                        this.startBGM();
                    }
                } else if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },

            toggleMute: function() {
                this.isMuted = !this.isMuted;
                const btn = document.getElementById('mute-btn');
                if(this.isMuted) {
                    if(this.ctx) this.ctx.suspend();
                    btn.innerText = 'üîá';
                } else {
                    if(this.ctx) this.ctx.resume();
                    btn.innerText = 'üîä';
                }
            },

            playTone: function(freq, type, duration, startTime = 0, vol = 0.1) {
                if (!this.ctx || this.isMuted) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime + startTime);
                
                gain.gain.setValueAtTime(vol, this.ctx.currentTime + startTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + startTime + duration);
                
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(this.ctx.currentTime + startTime);
                osc.stop(this.ctx.currentTime + startTime + duration);
            },

            play: function(name) {
                if (!this.ctx || this.isMuted) return;
                
                const now = 0;
                switch(name) {
                    case 'build':
                        // Ascending "blip"
                        this.playTone(220, 'square', 0.1, now, 0.05);
                        this.playTone(440, 'square', 0.1, now + 0.05, 0.05);
                        break;
                    case 'destroy':
                        // Low crumbling noise (sawtooth approximation)
                        this.playTone(100, 'sawtooth', 0.15, now, 0.1);
                        this.playTone(60, 'sawtooth', 0.2, now + 0.05, 0.1);
                        break;
                    case 'attack':
                        // Quick noise burst
                        this.playTone(150, 'square', 0.05, now, 0.05);
                        this.playTone(100, 'sawtooth', 0.05, now, 0.05);
                        break;
                    case 'ui':
                        // High tick
                        this.playTone(800, 'sine', 0.05, now, 0.05);
                        break;
                    case 'money':
                        // Coin ping
                        this.playTone(1200, 'sine', 0.1, now, 0.05);
                        this.playTone(1800, 'sine', 0.2, now + 0.05, 0.05);
                        break;
                    case 'alert':
                         this.playTone(300, 'square', 0.3, now, 0.1);
                         this.playTone(250, 'square', 0.3, now + 0.2, 0.1);
                         break;
                }
            },

            startBGM: function() {
                // Very simple procedural ambient loop
                let noteIdx = 0;
                // C Major Pentatonicish ambient
                const freqs = [261.63, 329.63, 392.00, 523.25, 392.00, 329.63]; 
                
                if (this.bgmInterval) clearInterval(this.bgmInterval);

                this.bgmInterval = setInterval(() => {
                    if(this.isMuted || !this.ctx || this.ctx.state === 'suspended') return;
                    
                    // Play a soft ambient note every 3 seconds
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    
                    osc.type = 'triangle';
                    osc.frequency.value = freqs[noteIdx % freqs.length];
                    
                    // Very slow attack and release for ambient feel
                    const t = this.ctx.currentTime;
                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(0.03, t + 1); // Fade in
                    gain.gain.linearRampToValueAtTime(0, t + 4); // Fade out
                    
                    osc.connect(gain);
                    gain.connect(this.ctx.destination);
                    
                    osc.start(t);
                    osc.stop(t + 4.5);
                    
                    noteIdx++;
                }, 3000);
            }
        };

        // --- UI Functions ---
        function toggleBuildWindow() {
            SoundManager.play('ui');
            const container = document.getElementById('build-bar-container');
            const handle = document.getElementById('minimize-handle');
            container.classList.toggle('minimized');
            
            if (container.classList.contains('minimized')) {
                handle.innerText = '‚ñ≤';
            } else {
                handle.innerText = '‚ñº';
            }
        }

        function toggleSpeed() {
            SoundManager.play('ui');
            const btn = document.getElementById('speed-btn');
            if (timeScale === 1.0) {
                timeScale = 2.0;
                btn.innerText = "x2";
                btn.classList.add('active');
            } else if (timeScale === 2.0) {
                timeScale = 4.0;
                btn.innerText = "x4";
                btn.classList.add('active');
            } else {
                timeScale = 1.0;
                btn.innerText = "x1";
                btn.classList.remove('active');
            }
        }

        function togglePause() {
            SoundManager.play('ui');
            isPaused = !isPaused;
            const btn = document.getElementById('pause-btn');
            if (isPaused) {
                btn.innerText = "‚ñ∂";
                btn.classList.add('active');
            } else {
                btn.innerText = "‚è∏";
                btn.classList.remove('active');
            }
        }

        function clearSelection() {
            if (selectedBuildingKey && gameGrid[selectedBuildingKey]) {
                // Remove highlight if we added one (currently relying on UI presence)
            }
            selectedBuildingKey = null;
            document.getElementById('selection-menu').classList.remove('active');
        }

        function rotateSelection() {
            SoundManager.play('ui');
            if (!selectedBuildingKey || !gameGrid[selectedBuildingKey]) return;
            const building = gameGrid[selectedBuildingKey];
            
            // Rotate visually
            building.mesh.rotation.y += Math.PI / 2;
        }

        function demolishSelection() {
            if (!selectedBuildingKey) return;
            const [x, z] = selectedBuildingKey.split(',').map(Number);
            removeBuilding(x, z);
            clearSelection();
        }

        // --- Three.js Globals ---
        let scene, camera, renderer;
        let raycaster, mouse;
        let placementCursor;
        let gridPlane;
        let isDragging = false;
        let isPanning = false;
        let lastPanPosition = { x: 0, y: 0 };
        let cameraTarget = new THREE.Vector3(0, 0, 0);
        let previousMousePosition = { x: 0, y: 0 };
        let cameraAngle = Math.PI / 4; // 45 degrees

        const geometryCache = new THREE.BoxGeometry(1, 1, 1);
        
        // --- Entities ---
        let villagers = [];
        let invaders = [];
        const VILLAGER_SPEED = 0.5;
        const INVADER_SPEED = 0.4;

        class Invader {
            constructor() {
                this.mesh = new THREE.Group();
                
                // --- DIFFICULTY SCALING ---
                // Base stats are significantly lower than original (60HP/10DMG)
                // But scale with dayCount to ensure rising difficulty
                const baseHp = 30;
                const hpPerDay = 5;
                this.maxHp = baseHp + (dayCount * hpPerDay);
                this.hp = this.maxHp;

                const baseDmg = 5;
                const dmgPerDay = 1; 
                this.damage = baseDmg + Math.floor(dayCount * dmgPerDay);
                
                this.attackCooldown = 0;
                this.target = null; 
                
                // Model
                const matBlack = new THREE.MeshLambertMaterial({color: 0x222222});
                const matRed = new THREE.MeshBasicMaterial({color: 0xFF0000});
                
                // Body
                const body = new THREE.Mesh(new THREE.BoxGeometry(2.2, 3.5, 1.8), matBlack);
                body.position.y = 1.75;
                this.mesh.add(body);
                
                // Head
                const head = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), matBlack);
                head.position.y = 4.5;
                this.mesh.add(head);
                
                // Eyes
                const eyes = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.5, 0.2), matRed);
                eyes.position.set(0, 4.5, 1.0);
                this.mesh.add(eyes);

                // Horns
                const hornL = new THREE.Mesh(new THREE.ConeGeometry(0.3, 1.5), matBlack);
                hornL.position.set(-0.8, 5.5, 0);
                hornL.rotation.z = 0.5;
                this.mesh.add(hornL);
                const hornR = new THREE.Mesh(new THREE.ConeGeometry(0.3, 1.5), matBlack);
                hornR.position.set(0.8, 5.5, 0);
                hornR.rotation.z = -0.5;
                this.mesh.add(hornR);

                this.mesh.scale.set(0.6, 0.6, 0.6);
                
                // Spawn logic
                const edge = Math.floor(Math.random() * 4);
                const dist = (GRID_SIZE * TILE_SIZE / 2) + 10;
                let ix=0, iz=0;
                if(edge===0) { ix = -dist; iz = (Math.random()-0.5)*dist*2; }
                else if(edge===1) { ix = dist; iz = (Math.random()-0.5)*dist*2; }
                else if(edge===2) { iz = -dist; ix = (Math.random()-0.5)*dist*2; }
                else { iz = dist; ix = (Math.random()-0.5)*dist*2; }
                
                this.mesh.position.set(ix, 0, iz);
                scene.add(this.mesh);
            }

            update(dt) {
                if (this.attackCooldown > 0) this.attackCooldown -= dt;

                // AI: Find Target
                if (!this.target || (this.target.mesh && !this.target.mesh.parent)) {
                    this.findTarget();
                }

                // COLLISION CHECK FOR WALLS
                // If we step into a wall tile, we must destroy it to pass
                const myGridX = Math.round(this.mesh.position.x / TILE_SIZE);
                const myGridZ = Math.round(this.mesh.position.z / TILE_SIZE);
                const key = `${myGridX},${myGridZ}`;
                
                if (gameGrid[key] && gameGrid[key].type === 'wall') {
                    // We walked into a wall. Break it.
                    if (this.target !== gameGrid[key]) {
                        this.target = gameGrid[key];
                    }
                }

                if (this.target) {
                    let targetPos;
                    if (this.target.mesh) targetPos = this.target.mesh.position; // Entity/Building
                    else targetPos = this.target.position; // Generic Vector3

                    const pos = this.mesh.position;
                    const dist = pos.distanceTo(targetPos);

                    // Attack range
                    if (dist < 4) {
                        if (this.attackCooldown <= 0) {
                            this.attack();
                            this.attackCooldown = 1000; 
                        }
                    } else {
                        // Move
                        const dir = new THREE.Vector3().subVectors(targetPos, pos).normalize();
                        pos.add(dir.multiplyScalar(INVADER_SPEED * (dt/16)));
                        this.mesh.lookAt(targetPos.x, pos.y, targetPos.z);
                        this.mesh.position.y = Math.abs(Math.sin(Date.now() * 0.008)) * 0.5;
                    }
                }
            }

            findTarget() {
                // 1. Guards
                const guards = villagers.filter(v => v.role === 'guard' && v.mesh.visible);
                if (guards.length > 0) {
                    let close = guards[0];
                    let minDist = this.mesh.position.distanceTo(close.mesh.position);
                    for(let g of guards) {
                        const d = this.mesh.position.distanceTo(g.mesh.position);
                        if(d < minDist) { minDist = d; close = g; }
                    }
                    this.target = close;
                    return;
                }

                // 2. Buildings (Prioritize high value, ignore walls/nature/houses as destinations)
                const buildings = Object.values(gameGrid).filter(b => {
                    return !['wall', 'tree', 'bush', 'rock', 'house'].includes(b.type);
                });
                
                if (buildings.length > 0) {
                    // Target closest building
                    let close = buildings[0];
                    let minDist = this.mesh.position.distanceTo(close.mesh.position);
                    for(let b of buildings) {
                        const d = this.mesh.position.distanceTo(b.mesh.position);
                        if(d < minDist) { minDist = d; close = b; }
                    }
                    this.target = close;
                    return;
                }

                // 3. Center
                this.target = { position: new THREE.Vector3(0, 0, 0) };
            }

            attack() {
                // new TWEEN_Pop(this.mesh.scale, 0.7); // Removed bounce
                SoundManager.play('attack');

                if (this.target instanceof Villager) {
                    this.target.takeDamage(this.damage);
                } else if (this.target.type) {
                    // Attack Building
                    const building = this.target;
                    if (!building.data.hp) building.data.hp = BUILDING_TYPES[building.type].hp || 50;
                    
                    building.data.hp -= this.damage;
                    
                    // Visual Feedback removed (Red flash)

                    if (building.data.hp <= 0) {
                        const tKey = Object.keys(gameGrid).find(key => gameGrid[key] === this.target);
                        if (tKey) {
                            const [x, z] = tKey.split(',').map(Number);
                            // CRITICAL: Flag as destroyed by invader so no resources are refunded
                            removeBuilding(x, z, { destroyedByInvader: true });
                            showToast(`Invaders destroyed a ${building.type}!`);
                            this.target = null;
                        }
                    }
                }
            }

            takeDamage(amount) {
                this.hp -= amount;
                this.mesh.children[0].material.color.setHex(0xFF0000);
                setTimeout(() => {
                    if(this.mesh) this.mesh.children[0].material.color.setHex(0x222222);
                }, 100);

                if (this.hp <= 0) {
                    this.die();
                }
            }

            die() {
                createParticles(this.mesh.position.x, 2, this.mesh.position.z, 0x222222);
                scene.remove(this.mesh);
                invaders = invaders.filter(i => i !== this);
            }
        }

        class Villager {
            constructor() {
                this.mesh = new THREE.Group();
                this.role = 'villager';
                this.state = 'idle'; 
                this.inventory = { wood: 0, stone: 0, gold: 0 };
                this.workTarget = null; 
                this.homeBase = null;
                this.guardTimer = 0;
                this.guardLevel = 1;
                this.paymentRetry = 0;
                this.assignedTower = null;
                
                // Stats
                this.hp = 100;
                this.maxHp = 100;
                this.attackDamage = 20;
                this.attackCooldown = 0;
                this.combatTarget = null;

                // Body
                const bodyGeo = new THREE.BoxGeometry(2, 3, 1.5);
                this.bodyMat = new THREE.MeshLambertMaterial({color: 0x2196F3}); 
                const body = new THREE.Mesh(bodyGeo, this.bodyMat);
                body.position.y = 1.5;
                body.castShadow = true;
                this.mesh.add(body);

                // Head
                const headGeo = new THREE.BoxGeometry(2, 2, 2);
                const headMat = new THREE.MeshLambertMaterial({color: 0xFFCC80}); 
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.y = 4;
                head.castShadow = true;
                this.mesh.add(head);

                // Hat (Farmer)
                const hatGeo = new THREE.ConeGeometry(2.5, 1.5, 8);
                const hatMat = new THREE.MeshLambertMaterial({color: 0xE4D00A});
                this.hat = new THREE.Mesh(hatGeo, hatMat);
                this.hat.position.y = 5.5;
                this.hat.visible = false;
                this.mesh.add(this.hat);

                // Helmet (Guard)
                const helmGeo = new THREE.BoxGeometry(2.2, 2.2, 2.2);
                const helmMat = new THREE.MeshLambertMaterial({color: 0xA9A9A9}); 
                this.helmet = new THREE.Mesh(helmGeo, helmMat);
                this.helmet.position.y = 4;
                this.helmet.visible = false;
                this.mesh.add(this.helmet);

                // Torch (Guard)
                this.torch = new THREE.Group();
                const torchHandle = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.5, 0.3), new THREE.MeshLambertMaterial({color: 0x8B4513}));
                const torchHead = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshBasicMaterial({color: 0xFF4500}));
                torchHead.position.y = 0.8;
                const torchLight = new THREE.PointLight(0xFF6600, 1.5, 15);
                torchLight.position.y = 1.0;
                this.torch.add(torchHandle);
                this.torch.add(torchHead);
                this.torch.add(torchLight);
                this.torch.position.set(1.2, 2.5, 0.8); 
                this.torch.rotation.x = Math.PI / 4;
                this.torch.visible = false;
                this.mesh.add(this.torch);
                
                // Legs
                const legGeo = new THREE.BoxGeometry(0.8, 1.5, 0.8);
                const legMat = new THREE.MeshLambertMaterial({color: 0x333333});
                const legL = new THREE.Mesh(legGeo, legMat);
                legL.position.set(-0.5, 0, 0);
                this.mesh.add(legL);
                const legR = new THREE.Mesh(legGeo, legMat);
                legR.position.set(0.5, 0, 0);
                this.mesh.add(legR);

                this.mesh.scale.set(0.6, 0.6, 0.6); 
                
                this.target = new THREE.Vector3(0, 0, 0);
                this.pickNewTarget();
                
                const r = (Math.random() - 0.5) * GRID_SIZE * TILE_SIZE * 0.5;
                this.mesh.position.set(r, 0, r);

                scene.add(this.mesh);
            }

            // Helper to clear resource reservation
            releaseReservation() {
                if (this.workTarget && gameGrid[this.workTarget] && gameGrid[this.workTarget].reservedBy === this) {
                    gameGrid[this.workTarget].reservedBy = null;
                }
                this.workTarget = null;
            }

            setRole(newRole, level = 1) {
                if (this.role === newRole && this.guardLevel === level) return;
                
                // Release any current resource reservations before switching
                this.releaseReservation();

                // If leaving guard role, free up the slot
                if (this.role === 'guard' && newRole !== 'guard') {
                    if (this.assignedTower && this.assignedTower.data) {
                        this.assignedTower.data.guards = Math.max(0, (this.assignedTower.data.guards || 0) - 1);
                    }
                    this.assignedTower = null;
                }

                this.hat.visible = false;
                this.helmet.visible = false;
                this.torch.visible = false;
                this.bodyMat.emissive.setHex(0x000000);
                
                this.role = newRole;
                this.bodyMat.color.setHex(0x2196F3); 

                if (newRole === 'farmer') {
                    this.hat.visible = true;
                } else if (newRole === 'lumberjack') {
                    this.bodyMat.color.setHex(0xD32F2F); 
                } else if (newRole === 'miner') {
                    this.bodyMat.color.setHex(0x333333); 
                } else if (newRole === 'guard') {
                    this.bodyMat.color.setHex(0x607D8B); 
                    this.helmet.visible = true;
                    this.torch.visible = true;
                    this.guardLevel = level;
                    
                    if (level === 2) {
                        this.hp = 300;
                        this.attackDamage = 50;
                        this.bodyMat.emissive.setHex(0x550000); 
                        this.torch.children[2].color.setHex(0xFF0000); 
                    } else {
                        this.hp = 100;
                        this.attackDamage = 20;
                        this.torch.children[2].color.setHex(0xFF6600); 
                    }
                }

                this.state = 'idle';
                this.inventory = { wood: 0, stone: 0, gold: 0 };
                this.pickNewTarget();
            }

            pickNewTarget() {
                if (!isDayTime && this.role !== 'guard') {
                    const houses = Object.values(gameGrid).filter(b => b.type === 'house');
                    if (houses.length > 0) {
                        const house = houses[Math.floor(Math.random() * houses.length)];
                        this.target.copy(house.mesh.position);
                        this.state = 'going_home';
                    } else {
                        this.state = 'sleeping';
                        this.target.copy(this.mesh.position); 
                    }
                    return;
                }

                if (this.role === 'guard') {
                     if (this.state === 'seeking_payment') {
                        // Keep logic in update
                        return;
                     }

                     if (invaders.length > 0) {
                         let close = invaders[0];
                         let minDist = this.mesh.position.distanceTo(close.mesh.position);
                         for(let i of invaders) {
                             const d = this.mesh.position.distanceTo(i.mesh.position);
                             if (d < minDist) { minDist = d; close = i; }
                         }
                         
                         if (minDist < 30) { 
                             this.state = 'combat';
                             this.combatTarget = close;
                             this.target.copy(close.mesh.position);
                             return;
                         }
                     }

                     const rX = (Math.floor(Math.random() * GRID_SIZE) - GRID_SIZE/2) * TILE_SIZE;
                     const rZ = (Math.floor(Math.random() * GRID_SIZE) - GRID_SIZE/2) * TILE_SIZE;
                     this.target.set(rX, 0, rZ);
                     return;
                }

                if (this.role === 'farmer') {
                    const farms = Object.values(gameGrid).filter(b => b.type === 'farm');
                    if (farms.length > 0) {
                        const f = farms[Math.floor(Math.random() * farms.length)];
                        const jx = (Math.random() - 0.5) * (TILE_SIZE * 0.8);
                        const jz = (Math.random() - 0.5) * (TILE_SIZE * 0.8);
                        this.target.copy(f.mesh.position).add(new THREE.Vector3(jx, 0, jz));
                        return;
                    }
                }
                if (this.role === 'lumberjack') {
                    this.updateGathererAI(['tree', 'bush'], 'lumber');
                    return;
                }
                if (this.role === 'miner') {
                    this.updateGathererAI(['rock'], 'mine');
                    return;
                }
                
                // CHANGED: Significantly increased priority for checking towers (Guards High Priority)
                if (this.role === 'villager') {
                    const towers = Object.values(gameGrid).filter(b => b.type === 'tower' || b.type === 'tower_lvl2');
                    if (towers.length > 0) {
                        // Check if any tower has gold and vacancy
                        const vacancy = towers.find(t => t.data.gold >= 5 && (t.data.guards || 0) < 5);
                        
                        if (vacancy) {
                            const tower = vacancy; // Go to the first available one or random logic below
                            this.state = 'checking_tower';
                            this.workTarget = tower; 
                            const jx = (Math.random() - 0.5) * (TILE_SIZE * 1.5);
                            const jz = (Math.random() - 0.5) * (TILE_SIZE * 1.5);
                            this.target.copy(tower.mesh.position).add(new THREE.Vector3(jx, 0, jz));
                            return;
                        }
                    }
                }

                this.state = 'wandering';
                const rX = (Math.floor(Math.random() * GRID_SIZE) - GRID_SIZE/2) * TILE_SIZE;
                const rZ = (Math.floor(Math.random() * GRID_SIZE) - GRID_SIZE/2) * TILE_SIZE;
                this.target.set(rX, 0, rZ);
            }

            updateGathererAI(targetTypes, depotType) {
                // 1. Delivery Check
                if (this.inventory.wood > 0 || this.inventory.stone > 0 || this.inventory.gold > 0) {
                    this.releaseReservation(); // Done with resource
                    this.state = 'returning';
                    const depots = Object.values(gameGrid).filter(b => b.type === depotType);
                    if (depots.length > 0) {
                        // Find closest depot
                        let closest = depots[0];
                        let minD = this.mesh.position.distanceTo(depots[0].mesh.position);
                        for(let d of depots) {
                            const dist = this.mesh.position.distanceTo(d.mesh.position);
                            if(dist < minD) { minD = dist; closest = d; }
                        }
                        this.target.copy(closest.mesh.position);
                    } else {
                         const rX = (Math.floor(Math.random() * GRID_SIZE) - GRID_SIZE/2) * TILE_SIZE;
                         const rZ = (Math.floor(Math.random() * GRID_SIZE) - GRID_SIZE/2) * TILE_SIZE;
                         this.target.set(rX, 0, rZ);
                    }
                    return;
                }

                // 2. Find New Resource
                this.state = 'working';
                let bestDist = Infinity;
                let bestKey = null;
                let bestPos = null;
                
                for (let key in gameGrid) {
                    const entry = gameGrid[key];
                    // Check type AND if reserved (or reserved by me)
                    if (targetTypes.includes(entry.type) && (!entry.reservedBy || entry.reservedBy === this)) {
                        const dist = this.mesh.position.distanceTo(entry.mesh.position);
                        if (dist < bestDist) {
                            bestDist = dist;
                            bestKey = key;
                            bestPos = entry.mesh.position;
                        }
                    }
                }

                if (bestKey) {
                    // Found a valid, unreserved resource
                    if (this.workTarget !== bestKey) {
                        this.releaseReservation(); // Clear old if switching
                        this.workTarget = bestKey;
                        gameGrid[bestKey].reservedBy = this; // Reserve it
                    }
                    this.target.copy(bestPos);
                } else {
                    // 3. No Resources? Go to Station
                    this.releaseReservation();
                    this.state = 'idle_at_station';
                    
                    const stations = Object.values(gameGrid).filter(b => b.type === depotType);
                    if (stations.length > 0) {
                        // Find closest station
                        let closest = stations[0];
                        let minD = this.mesh.position.distanceTo(stations[0].mesh.position);
                        for(let s of stations) {
                            const dist = this.mesh.position.distanceTo(s.mesh.position);
                            if(dist < minD) { minD = dist; closest = s; }
                        }
                        // Stand near the station
                        const jx = (Math.random() - 0.5) * (TILE_SIZE * 0.8);
                        const jz = (Math.random() - 0.5) * (TILE_SIZE * 0.8);
                        this.target.copy(closest.mesh.position).add(new THREE.Vector3(jx, 0, jz));
                    } else {
                        // No station exists? Just wander.
                        this.state = 'wandering';
                        const rX = (Math.floor(Math.random() * GRID_SIZE) - GRID_SIZE/2) * TILE_SIZE;
                        const rZ = (Math.floor(Math.random() * GRID_SIZE) - GRID_SIZE/2) * TILE_SIZE;
                        this.target.set(rX, 0, rZ);
                    }
                }
            }

            takeDamage(amount) {
                this.hp -= amount;
                this.bodyMat.color.setHex(0xFF0000);
                setTimeout(() => {
                    if(this.mesh) {
                        if (this.role === 'guard') this.bodyMat.color.setHex(0x607D8B);
                        else this.bodyMat.color.setHex(0x2196F3); 
                    }
                }, 100);

                if (this.hp <= 0) {
                    createParticles(this.mesh.position.x, 2, this.mesh.position.z, 0xFF0000);
                    
                    // Cleanup reservations on death
                    this.releaseReservation();

                    // If a guard dies, free the slot in their assigned tower
                    if (this.role === 'guard' && this.assignedTower && this.assignedTower.data) {
                        this.assignedTower.data.guards = Math.max(0, (this.assignedTower.data.guards || 0) - 1);
                    }
                    this.remove();
                    villagers = villagers.filter(v => v !== this);
                    RESOURCES.pop--;
                    updateUI();
                    showToast("A villager has fallen!");
                }
            }

            update(dt) {
                if (this.attackCooldown > 0) this.attackCooldown -= dt;

                if (isDayTime && (this.state === 'sleeping' || this.state === 'going_home')) {
                    this.state = 'idle';
                    this.mesh.visible = true; 
                    this.mesh.rotation.z = 0; 
                    this.mesh.position.y = 0; 
                    this.pickNewTarget();
                } else if (!isDayTime && this.role !== 'guard' && this.state !== 'sleeping' && this.state !== 'going_home') {
                    this.pickNewTarget();
                }

                if (this.role === 'guard') {
                    this.guardTimer -= dt;
                    if (this.guardTimer <= 0) {
                        // Try to get paid
                        this.state = 'seeking_payment';
                        
                        // Prioritize current tower if it exists and has capacity (vacancies are effectively 1 since we are already hired)
                        // Or find any tower with Gold >= 5 AND Guards < 5
                        const validTowers = Object.values(gameGrid).filter(b => {
                            if (b.type !== 'tower' && b.type !== 'tower_lvl2') return false;
                            if (b.data.gold < 5) return false;
                            
                            // If this is MY tower, I'm already counted, so I don't need a vacancy.
                            if (b === this.assignedTower) return true;
                            
                            // Otherwise, need a vacancy
                            return (b.data.guards || 0) < 5;
                        });
                        
                        if (validTowers.length > 0) {
                            // Find closest
                            let close = validTowers[0];
                            let minDist = this.mesh.position.distanceTo(close.mesh.position);
                            for(let t of validTowers) {
                                const d = this.mesh.position.distanceTo(t.mesh.position);
                                if(d < minDist) { minDist = d; close = t; }
                            }
                            this.target.copy(close.mesh.position);
                            this.workTarget = close;
                            this.paymentRetry = 10000; // 10s to reach it
                            this.guardTimer = 999999; // Prevent re-triggering
                        } else {
                            this.setRole('villager');
                            showToast("A guard retired (no payment/vacancy).");
                        }
                    }
                }

                if (this.state === 'seeking_payment') {
                    this.paymentRetry -= dt;
                    if (this.paymentRetry <= 0) {
                         this.setRole('villager');
                         showToast("A guard retired (couldn't reach payment).");
                         return;
                    }
                    
                    const tower = this.workTarget;
                    if (tower && tower.mesh.parent && tower.data.gold >= 5) {
                        // Moving to it...
                        const dist = this.mesh.position.distanceTo(tower.mesh.position);
                        if (dist < 2) {
                            // Check capacity one last time before transaction
                            // If it's a new tower, ensure space. If same tower, proceed.
                            if (tower !== this.assignedTower && (tower.data.guards || 0) >= 5) {
                                // Lost the spot while walking
                                this.guardTimer = 0; 
                                return;
                            }

                            tower.data.gold -= 5;
                            SoundManager.play('money');
                            
                            // Handle transfer
                            if (tower !== this.assignedTower) {
                                if (this.assignedTower && this.assignedTower.data) {
                                    this.assignedTower.data.guards = Math.max(0, (this.assignedTower.data.guards || 0) - 1);
                                }
                                this.assignedTower = tower;
                                this.assignedTower.data.guards = (this.assignedTower.data.guards || 0) + 1;
                            }

                            this.guardTimer = GUARD_DURATION;
                            this.state = 'idle';
                            showToast("Guard contract renewed! (-5 Gold)");
                            createParticles(this.mesh.position.x, 5, this.mesh.position.z, 0xFFD700);
                            this.pickNewTarget();
                            return;
                        }
                    } else {
                        // Tower destroyed or empty while walking
                        this.guardTimer = 0; // Trigger search again or retire
                    }
                }

                if (this.state === 'sleeping') {
                    if (this.mesh.visible) {
                        this.mesh.rotation.z = -Math.PI / 2;
                        this.mesh.position.y = 0.5;
                    }
                    return; 
                }

                if (this.state === 'combat' && this.combatTarget) {
                    if (!invaders.includes(this.combatTarget)) {
                        this.combatTarget = null;
                        this.pickNewTarget();
                        return;
                    }
                    this.target.copy(this.combatTarget.mesh.position);
                    const dist = this.mesh.position.distanceTo(this.target);
                    
                    if (dist < 3) {
                        if (this.attackCooldown <= 0) {
                            // new TWEEN_Pop(this.mesh.scale, 0.7); // Removed bounce
                            SoundManager.play('attack');
                            this.combatTarget.takeDamage(this.attackDamage);
                            this.attackCooldown = 1000; 
                        }
                        return; 
                    }
                }

                const pos = this.mesh.position;
                const dir = new THREE.Vector3().subVectors(this.target, pos);
                const dist = dir.length();
                
                if (dist < 1) {
                    if (this.state === 'going_home') {
                        this.state = 'sleeping';
                        this.mesh.visible = false; 
                        return;
                    }

                    if (this.state === 'checking_tower') {
                        const tower = this.workTarget;
                        // Added check for guard capacity < 5
                        if (tower && tower.mesh.parent && tower.data.gold >= 5 && (tower.data.guards || 0) < 5) {
                            tower.data.gold -= 5;
                            SoundManager.play('money');
                            this.assignedTower = tower;
                            this.assignedTower.data.guards = (this.assignedTower.data.guards || 0) + 1;
                            
                            this.setRole('guard', tower.data.level); 
                            this.guardTimer = GUARD_DURATION;
                            showToast(`A new guard (Lvl ${tower.data.level}) has been hired! (-5 Gold)`);
                            // new TWEEN_Pop(tower.mesh.scale, TILE_SIZE/10); // Removed bounce
                        } else {
                            this.setRole('villager'); 
                        }
                        this.pickNewTarget();
                        return;
                    }

                    if (this.role === 'lumberjack' || this.role === 'miner') {
                        const targetTypes = this.role === 'lumberjack' ? ['tree', 'bush'] : ['rock'];
                        const depotType = this.role === 'lumberjack' ? 'lumber' : 'mine';

                        if (this.state === 'working') {
                            const gridKey = this.workTarget;
                            
                            // Validate target exists and is ours
                            if (gameGrid[gridKey] && gameGrid[gridKey].reservedBy === this) {
                                const coords = gridKey.split(',');
                                const x = parseInt(coords[0]);
                                const z = parseInt(coords[1]);
                                removeBuilding(x, z, { gatherer: this });
                                this.updateGathererAI(targetTypes, depotType); 
                            } else {
                                // Target lost or stolen (shouldn't happen with reservation, but safety first)
                                this.updateGathererAI(targetTypes, depotType);
                            }
                        } else if (this.state === 'returning') {
                            if (this.inventory.wood > 0) RESOURCES.wood += this.inventory.wood;
                            if (this.inventory.stone > 0) RESOURCES.stone += this.inventory.stone;
                            if (this.inventory.gold > 0) {
                                RESOURCES.gold += this.inventory.gold;
                                SoundManager.play('money');
                            }
                            this.inventory = { wood: 0, stone: 0, gold: 0 };
                            updateUI();
                            this.updateGathererAI(targetTypes, depotType);
                        } else if (this.state === 'wandering') {
                            this.updateGathererAI(targetTypes, depotType);
                        } else if (this.state === 'idle_at_station') {
                            // Periodically check for new work
                            if (Math.random() < 0.05) {
                                this.updateGathererAI(targetTypes, depotType);
                            }
                        }
                    } else {
                        if (Math.random() < 0.02) this.pickNewTarget();
                    }
                } else {
                    dir.normalize();
                    pos.add(dir.multiplyScalar(VILLAGER_SPEED * (dt/16))); 
                    this.mesh.lookAt(this.target.x, this.mesh.position.y, this.target.z);
                    const time = Date.now() * 0.01;
                    this.mesh.position.y = Math.abs(Math.sin(time)) * 0.5;
                }
            }
            
            remove() {
                scene.remove(this.mesh);
            }
        }

        // --- Initialization ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 300, 900); 

            const aspect = window.innerWidth / window.innerHeight;
            const d = 100;
            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
            updateCameraPosition();

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // --- Lighting ---
            ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
            sunLight.position.set(-100, 150, -50);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.left = -200;
            sunLight.shadow.camera.right = 200;
            sunLight.shadow.camera.top = 200;
            sunLight.shadow.camera.bottom = -200;
            scene.add(sunLight);

            // --- Environment ---
            const groundGeo = new THREE.PlaneGeometry(GRID_SIZE * TILE_SIZE * 3, GRID_SIZE * TILE_SIZE * 3, 60, 60);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x4caf50, roughness: 0.8, metalness: 0.1 });
            gridPlane = new THREE.Mesh(groundGeo, groundMat);
            gridPlane.rotation.x = -Math.PI / 2;
            gridPlane.position.set(TILE_SIZE / 2, 0, TILE_SIZE / 2);
            gridPlane.receiveShadow = true;
            scene.add(gridPlane);

            const gridHelper = new THREE.GridHelper(GRID_SIZE * TILE_SIZE, GRID_SIZE, 0x2E7D32, 0x388E3C);
            gridHelper.position.set(TILE_SIZE / 2, 0.05, TILE_SIZE / 2);
            scene.add(gridHelper);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            const cursorGeo = new THREE.BoxGeometry(TILE_SIZE, 1, TILE_SIZE);
            const cursorMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
            placementCursor = new THREE.Mesh(cursorGeo, cursorMat);
            scene.add(placementCursor);

            // KEYBOARD LISTENER
            window.addEventListener('keydown', onKeyDown, false);

            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('wheel', onMouseWheel, { passive: false });
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false);
            document.addEventListener('contextmenu', event => event.preventDefault());

            generateSurroundings(); 
            updateUI();
            
            dayTime = 0.15; 

            animate();
        }

        // Hotkey Handler
        function onKeyDown(event) {
            switch(event.key) {
                case '1': selectTool('wall'); break;
                case '2': selectTool('house'); break;
                case '3': selectTool('farm'); break;
                case '4': selectTool('lumber'); break;
                case '5': selectTool('mine'); break;
                case '6': selectTool('tower'); break;
                case '7': selectTool('campfire'); break;
                case 'Escape': clearSelection(); break;
                case ' ': togglePause(); break; // Spacebar for pause
            }
        }

        // --- Day/Night Cycle Logic ---
        function updateDayNightCycle(dt) {
            if (!isGameActive) return;

            // Increment time
            dayTime += dt / DAY_DURATION;
            if (dayTime > 1) {
                dayTime = 0;
                dayCount++;
                document.getElementById('time-display').innerText = `Day ${dayCount}`;
                document.getElementById('day-announcement').innerText = `Day ${dayCount}`;
                
                // Trigger Announcement
                const ann = document.getElementById('day-announcement');
                ann.classList.add('visible');
                setTimeout(() => ann.classList.remove('visible'), 3000);
                
                SoundManager.play('alert');

                // Despawn any surviving invaders at sunrise
                invaders.forEach(i => scene.remove(i.mesh));
                invaders = [];
            }

            const angle = Math.PI - (dayTime * Math.PI * 2);
            const sunHeight = Math.sin(angle); 
            
            // Game Logic flag (monsters, working)
            // Previously -0.2, now using same threshold but smooth visuals are separate
            isDayTime = sunHeight > -0.2; 

            const orbitRadius = 200;
            const sunX = Math.cos(angle) * orbitRadius;
            const sunY = Math.sin(angle) * orbitRadius;
            
            // Sun / Moon positioning
            if (isDayTime) {
                sunLight.position.set(sunX, Math.max(50, Math.abs(sunY)), -50);
                sunLight.intensity = THREE.MathUtils.lerp(0.2, 1.2, Math.max(0, sunHeight));
                ambientLight.intensity = THREE.MathUtils.lerp(0.2, 0.6, Math.max(0, sunHeight));
                sunLight.color.setHSL(0.1, 0.3, 0.9); 
            } else {
                const moonX = -sunX;
                sunLight.position.set(moonX, Math.max(50, Math.abs(sunY)), -50);
                sunLight.intensity = 0.3;
                sunLight.color.setHex(0xaaaaff); 
                ambientLight.intensity = 0.15;
            }

            // --- SMOOTH SKY COLOR INTERPOLATION ---
            const cDay = new THREE.Color(0x87CEEB);
            const cSunset = new THREE.Color(0xFF7F50);
            const cNight = new THREE.Color(0x0f1129);
            
            let currentSky = new THREE.Color();

            if (sunHeight > 0.2) {
                // Full Day
                currentSky.copy(cDay);
            } else if (sunHeight > 0.0) {
                // Day -> Sunset
                const t = (0.2 - sunHeight) / 0.2; // 0 to 1
                currentSky.copy(cDay).lerp(cSunset, t);
            } else if (sunHeight > -0.2) {
                // Sunset -> Night
                const t = (0.0 - sunHeight) / 0.2; // 0 to 1
                currentSky.copy(cSunset).lerp(cNight, t);
            } else {
                // Full Night
                currentSky.copy(cNight);
            }

            scene.background = currentSky;
            scene.fog.color = currentSky;
        }

        // --- Core Game Functions ---

        function startGame() {
            SoundManager.init();
            document.getElementById('modal-overlay').style.display = 'none';
            isGameActive = true;
            spawnRandom('tree', 15);
            spawnRandom('rock', 15);
            spawnRandom('bush', 15);
        }

        function spawnRandom(type, count) {
            for(let i=0; i<count; i++) {
                let rx = Math.floor(Math.random() * GRID_SIZE) - GRID_SIZE/2;
                let rz = Math.floor(Math.random() * GRID_SIZE) - GRID_SIZE/2;
                if (!gameGrid[`${rx},${rz}`]) {
                    placeBuilding(rx, rz, type, true);
                }
            }
        }

        function generateSurroundings() {
            const range = 30; 
            const inner = GRID_SIZE / 2 + 1; 

            for (let x = -range; x <= range; x++) {
                for (let z = -range; z <= range; z++) {
                    if (x >= -inner && x <= inner && z >= -inner && z <= inner) continue;

                    if (Math.random() < 0.4) {
                        const type = Math.random() < 0.6 ? 'tree' : (Math.random() < 0.5 ? 'bush' : 'rock');
                        const mesh = createVoxelGroup(type);
                        
                        const jx = (Math.random() - 0.5) * 5;
                        const jz = (Math.random() - 0.5) * 5;
                        
                        mesh.position.set(x * TILE_SIZE + jx, 0, z * TILE_SIZE + jz);
                        mesh.rotation.y = Math.random() * Math.PI * 2;
                        
                        scene.add(mesh);
                    }
                }
            }
        }

        function updateCameraPosition() {
            const distance = 200; 
            const cx = distance * Math.cos(cameraAngle);
            const cz = distance * Math.sin(cameraAngle);
            camera.position.set(cameraTarget.x + cx, 150, cameraTarget.z + cz);
            camera.lookAt(cameraTarget);
        }

        function createVoxelGroup(type) {
            const group = new THREE.Group();
            
            function addVoxel(x, y, z, color, sx=1, sy=1, sz=1) {
                const mat = new THREE.MeshLambertMaterial({ color: color });
                const mesh = new THREE.Mesh(geometryCache, mat);
                mesh.position.set(x, y, z);
                mesh.scale.set(sx, sy, sz);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                group.add(mesh);
            }

            const scale = TILE_SIZE / 10; 
            group.scale.set(scale, scale, scale);

            if (type === 'house') {
                addVoxel(0, 2.5, 0, 0xe0e0e0, 8, 5, 8); 
                addVoxel(0, 6, 0, 0xA52A2A, 9, 2, 9);
                addVoxel(0, 7.5, 0, 0xA52A2A, 7, 2, 7);
                addVoxel(0, 8.5, 0, 0xA52A2A, 4, 1, 4);
                addVoxel(0, 1.5, 4.1, 0x8B4513, 2, 3, 0.5);
            } 
            else if (type === 'tower' || type === 'tower_lvl2') {
                // Foundation
                addVoxel(0, 2, 0, 0x696969, 7, 4, 7);
                
                // Shaft
                addVoxel(0, 7, 0, 0x808080, 5, 8, 5);
                
                // Windows
                addVoxel(0, 7, 2.6, 0x333333, 1, 2, 0.2); 
                addVoxel(0, 7, -2.6, 0x333333, 1, 2, 0.2); 
                addVoxel(2.6, 7, 0, 0x333333, 0.2, 2, 1); 
                addVoxel(-2.6, 7, 0, 0x333333, 0.2, 2, 1); 
                
                // Platform
                addVoxel(0, 11.5, 0, 0x696969, 7, 1, 7);

                // Battlements
                const batH = 1.5;
                addVoxel(-3, 12.5, -3, 0x808080, 1.5, batH, 1.5);
                addVoxel(3, 12.5, 3, 0x808080, 1.5, batH, 1.5);
                addVoxel(-3, 12.5, 3, 0x808080, 1.5, batH, 1.5);
                addVoxel(3, 12.5, -3, 0x808080, 1.5, batH, 1.5);
                
                // Roof Color
                const roofColor = (type === 'tower_lvl2') ? 0xD32F2F : 0x4682B4;

                // Roof
                addVoxel(0, 12.5, 0, roofColor, 5, 1, 5); 
                addVoxel(0, 13.5, 0, roofColor, 3.5, 1.5, 3.5); 
                addVoxel(0, 15, 0, 0x5F9EA0, 2, 2, 2); 
                
                // Flag
                addVoxel(0, 17, 0, 0xDAA520, 0.2, 3, 0.2);
                addVoxel(0.8, 17.5, 0, 0xD32F2F, 1.5, 1, 0.1);

                // Internal Tower Light
                const towerLight = new THREE.PointLight(0xFFD700, 0, 20); // Start off
                towerLight.position.set(0, 12, 0);
                group.add(towerLight);
                group.userData.towerLight = towerLight;
            }
            else if (type === 'mine') {
                // Rock Mound
                addVoxel(0, 2, 0, 0x555555, 6, 4, 6); // Base
                addVoxel(0, 4.5, 0, 0x666666, 4, 2, 4); // Top
                
                // Dark Entrance
                addVoxel(0, 2, 2.5, 0x111111, 2, 3, 2);
                
                // Wooden supports
                addVoxel(-1.5, 2, 3.5, 0x8B4513, 0.5, 3, 0.5); // Post L
                addVoxel(1.5, 2, 3.5, 0x8B4513, 0.5, 3, 0.5);  // Post R
                addVoxel(0, 3.7, 3.5, 0x8B4513, 3.5, 0.5, 0.5); // Beam
            }
            else if (type === 'tree') {
                addVoxel(0, 2, 0, 0x8B4513, 2, 4, 2);
                addVoxel(0, 5, 0, 0x4CAF50, 6, 3, 6);
                addVoxel(0, 7.5, 0, 0x4CAF50, 4, 3, 4);
                addVoxel(0, 9.5, 0, 0x4CAF50, 2, 1, 2);
            }
            else if (type === 'bush') {
                addVoxel(0, 1, 0, 0x2E7D32, 5, 2, 5);
                addVoxel(-1.5, 2, -1, 0x2E7D32, 3, 2, 3);
                addVoxel(1.5, 1.5, 1.5, 0x388E3C, 2.5, 1.5, 2.5);
            }
            else if (type === 'rock') {
                addVoxel(0, 1, 0, 0x757575, 4, 2, 3);
                addVoxel(-1, 0.5, 1, 0x9E9E9E, 2, 1, 2);
                addVoxel(1.5, 0.5, -0.5, 0x616161, 2.5, 1, 2.5);
            }
            else if (type === 'farm') {
                // Enhanced Farm Model
                
                // Base Soil (Dark Brown)
                addVoxel(0, 0.5, 0, 0x5d4037, 9, 1, 9); 

                // Tilled Rows (3 raised rows)
                for(let i=-1; i<=1; i++) {
                    const zOffset = i * 2.5;
                    addVoxel(0, 1.2, zOffset, 0x3e2723, 8, 0.4, 1.5); // Darker tilled row

                    // Crops (Wheat/Corn) - varied logic
                    for(let j=-3; j<=3; j+=1.5) {
                         // Randomize height and color slightly for organic look
                         const h = 0.8 + Math.random() * 0.6; 
                         const color = Math.random() > 0.3 ? 0xfdd835 : 0x66bb6a; // Yellow vs Green crops
                         addVoxel(j, 1.4 + (h/2), zOffset, color, 0.5, h, 0.5);
                    }
                }

                // Fences (Corners)
                const fenceColor = 0x8d6e63;
                addVoxel(-4, 1.5, -4, fenceColor, 0.6, 2, 0.6);
                addVoxel(4, 1.5, -4, fenceColor, 0.6, 2, 0.6);
                addVoxel(-4, 1.5, 4, fenceColor, 0.6, 2, 0.6);
                addVoxel(4, 1.5, 4, fenceColor, 0.6, 2, 0.6);
                
                // Fence Rails (Long sides)
                addVoxel(0, 2, -4, fenceColor, 8, 0.3, 0.3);
                addVoxel(0, 2, 4, fenceColor, 8, 0.3, 0.3);
                addVoxel(-4, 2, 0, fenceColor, 0.3, 0.3, 8);
                addVoxel(4, 2, 0, fenceColor, 0.3, 0.3, 8);
            }
            else if (type === 'lumber') {
                addVoxel(-2, 1, -2, 0x8B4513, 3, 2, 3);
                addVoxel(-2, 3, -2, 0x777777, 0.5, 2, 0.5);
                addVoxel(2, 1, 2, 0xDEB887, 4, 2, 2);
            }
            else if (type === 'campfire') {
                addVoxel(1.5, 0.5, 0, 0x555555, 1, 1, 1);
                addVoxel(-1.5, 0.5, 0, 0x555555, 1, 1, 1);
                addVoxel(0, 0.5, 1.5, 0x555555, 1, 1, 1);
                addVoxel(0, 0.5, -1.5, 0x555555, 1, 1, 1);
                addVoxel(0, 0.5, 0, 0x8B4513, 2.5, 0.8, 0.8); 
                const log2 = new THREE.Mesh(geometryCache, new THREE.MeshLambertMaterial({color: 0x8B4513}));
                log2.position.set(0, 0.5, 0);
                log2.scale.set(0.8, 0.8, 2.5);
                group.add(log2);

                group.userData.fireParts = []; 
                
                function addFireVoxel(x, y, z, color) {
                     const mat = new THREE.MeshLambertMaterial({ 
                         color: color, 
                         emissive: color, 
                         emissiveIntensity: 0.8 
                     });
                     const mesh = new THREE.Mesh(geometryCache, mat);
                     mesh.position.set(x, y, z);
                     group.add(mesh);
                     group.userData.fireParts.push({ mesh: mesh, baseScale: mesh.scale.clone() });
                }
                
                addFireVoxel(0, 1.5, 0, 0xFF4500); 
                addFireVoxel(0.2, 2.5, 0.2, 0xFFA500); 
                addFireVoxel(-0.2, 3, -0.1, 0xFFD700); 

                const light = new THREE.PointLight(0xFFAA00, 2.5, 25); 
                light.position.set(0, 3, 0);
                light.castShadow = false;
                group.add(light);
                group.userData.light = light;
            }

            return group;
        }

        function createWallVisuals(x, z) {
            // Helper to check for wall connection
            function isWall(nx, nz) {
                const k = `${nx},${nz}`;
                return gameGrid[k] && (gameGrid[k].type === 'wall');
            }

            const group = new THREE.Group();
            
            // Helper func to add blocks
            function addV(lx, ly, lz, color, sx, sy, sz) {
                const mat = new THREE.MeshLambertMaterial({ color: color });
                const mesh = new THREE.Mesh(geometryCache, mat);
                mesh.position.set(lx, ly, lz);
                mesh.scale.set(sx, sy, sz);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                group.add(mesh);
            }
            
            const scale = TILE_SIZE / 10; 
            group.scale.set(scale, scale, scale);

            // Central Post (Always there)
            addV(0, 3.5, 0, 0x757575, 4, 7, 4); // Taller pillar
            addV(0, 7.5, 0, 0x888888, 4.2, 1, 4.2); // Cap

            // Check Neighbors
            const n = isWall(x, z-1); // North
            const s = isWall(x, z+1); // South
            const e = isWall(x+1, z); // East
            const w = isWall(x-1, z); // West

            // Add connectors
            const wallH = 6;
            const wallY = 3;
            const thick = 2.5;

            if (n) {
                addV(0, wallY, -3, 0x757575, thick, wallH, 6);
                // Crenellation N
                addV(0, 6.5, -3, 0x757575, thick, 1, 2);
            }
            if (s) {
                addV(0, wallY, 3, 0x757575, thick, wallH, 6);
                // Crenellation S
                addV(0, 6.5, 3, 0x757575, thick, 1, 2);
            }
            if (e) {
                addV(3, wallY, 0, 0x757575, 6, wallH, thick);
                // Crenellation E
                addV(3, 6.5, 0, 0x757575, 2, 1, thick);
            }
            if (w) {
                addV(-3, wallY, 0, 0x757575, 6, wallH, thick);
                // Crenellation W
                addV(-3, 6.5, 0, 0x757575, 2, 1, thick);
            }

            return group;
        }

        function updateWallNeighbors(x, z) {
            const neighbors = [
                {x: x, z: z-1},
                {x: x, z: z+1},
                {x: x-1, z: z},
                {x: x+1, z: z}
            ];

            neighbors.forEach(n => {
                const key = `${n.x},${n.z}`;
                if (gameGrid[key] && gameGrid[key].type === 'wall') {
                    // Replace mesh
                    scene.remove(gameGrid[key].mesh);
                    const newMesh = createWallVisuals(n.x, n.z);
                    newMesh.position.set(n.x * TILE_SIZE, 0, n.z * TILE_SIZE);
                    // Keep existing rotation? Walls are now symmetric/smart, rotation might not matter visually 
                    // but we keep it 0 for smart walls usually.
                    
                    scene.add(newMesh);
                    gameGrid[key].mesh = newMesh;
                }
            });
        }

        function placeBuilding(x, z, type, free = false) {
            const key = `${x},${z}`;
            
            if (x < -GRID_SIZE/2 || x > GRID_SIZE/2 || z < -GRID_SIZE/2 || z > GRID_SIZE/2) return;
            if (gameGrid[key]) return; 

            const buildingData = BUILDING_TYPES[type];
            if (!buildingData) return;

            if (!free) {
                if (RESOURCES.gold < buildingData.cost.gold || 
                    RESOURCES.wood < buildingData.cost.wood || 
                    RESOURCES.stone < buildingData.cost.stone) {
                    showToast("Not enough resources!");
                    return;
                }
                
                RESOURCES.gold -= buildingData.cost.gold;
                RESOURCES.wood -= buildingData.cost.wood;
                RESOURCES.stone -= buildingData.cost.stone;
            }

            let mesh;
            if (type === 'wall') {
                mesh = createWallVisuals(x, z);
            } else {
                mesh = createVoxelGroup(type);
            }
            
            mesh.position.set(x * TILE_SIZE, 0, z * TILE_SIZE);
            
            // Removed spawn bounce animation
            // mesh.scale.set(0.1, 0.1, 0.1);
            // new TWEEN_Pop(mesh.scale, TILE_SIZE/10);

            scene.add(mesh);
            SoundManager.play('build');

            // Store data (like gold for towers)
            // Initialize HP from type
            const hp = buildingData.hp || 50;
            gameGrid[key] = { type: type, mesh: mesh, data: { gold: 0, level: 1, hp: hp, guards: 0 } }; // Initialize guards count

            if (type === 'wall') {
                updateWallNeighbors(x, z);
            }

            if (buildingData.cap) RESOURCES.popCap += buildingData.cap;
            
            createParticles(x * TILE_SIZE, 5, z * TILE_SIZE, 0xFFFFFF);
            updateUI();
        }

        function removeBuilding(x, z, options = {}) {
            const key = `${x},${z}`;
            if (!gameGrid[key]) return;

            const entry = gameGrid[key];
            const data = BUILDING_TYPES[entry.type];

            if (data.cap) RESOURCES.popCap -= data.cap;
            
            // --- DEMOLITION REFUND ---
            // Logic: Only refund if NOT destroyed by invader and NOT a nature item (unless specific tools used)
            let shouldRefund = !options.gatherer && !options.destroyedByInvader && data.type !== 'nature';

            if (shouldRefund) {
                const cost = data.cost;
                if (cost) {
                    RESOURCES.gold += Math.floor(cost.gold * 0.5); // 50% refund usually fair
                    RESOURCES.wood += Math.floor(cost.wood * 0.5);
                    RESOURCES.stone += Math.floor(cost.stone * 0.5);
                }
            }

            let collected = { wood: 0, stone: 0, gold: 0 };

            // Nature Harvesting - ONLY if NOT destroyed by invader
            if (!options.destroyedByInvader) {
                if (entry.type === 'rock') {
                    const stoneAmt = Math.floor(Math.random() * 11) + 10; 
                    collected.stone += stoneAmt;
                    if (Math.random() < 0.2) { 
                        collected.gold += 1;
                        createParticles(x * TILE_SIZE, 5, z * TILE_SIZE, 0xFFD700);
                        SoundManager.play('money');
                    }
                } 
                else if (entry.type === 'tree') {
                    const woodAmt = Math.floor(Math.random() * 11) + 10; 
                    collected.wood += woodAmt;
                }
                else if (entry.type === 'bush') {
                    const woodAmt = Math.floor(Math.random() * 6) + 5; 
                    collected.wood += woodAmt;
                } 
            }

            if (options.gatherer) {
                options.gatherer.inventory.wood += collected.wood;
                options.gatherer.inventory.stone += collected.stone;
                options.gatherer.inventory.gold += collected.gold;
            } else {
                RESOURCES.stone += collected.stone;
                RESOURCES.wood += collected.wood;
                RESOURCES.gold += collected.gold;

                if (collected.stone > 0) showToast(`+${collected.stone} Stone`);
                if (collected.wood > 0) showToast(`+${collected.wood} Wood`);
                if (collected.gold > 0) {
                    showToast(`+${collected.gold} Gold`);
                    SoundManager.play('money');
                }
                
                if (shouldRefund) {
                    showToast(`Refunded materials for ${data.name}`);
                    SoundManager.play('money');
                }
            }

            scene.remove(entry.mesh);
            createParticles(x * TILE_SIZE, 5, z * TILE_SIZE, 0x555555);
            SoundManager.play('destroy');
            delete gameGrid[key];

            if (entry.type === 'wall') {
                updateWallNeighbors(x, z);
            }

            // If this was the selected building, clear selection
            if (selectedBuildingKey === key) {
                clearSelection();
            }

            updateUI();
        }

        function onMouseWheel(event) {
            event.preventDefault();

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(gridPlane);
            if (intersects.length === 0) return;
            const p1 = intersects[0].point.clone();

            const zoomSpeed = 0.001 * camera.zoom; 
            camera.zoom -= event.deltaY * zoomSpeed;
            // RESTRICTION: Changed min zoom from 0.5 to 0.8 to prevent seeing too much void
            camera.zoom = Math.max(0.8, Math.min(camera.zoom, 5)); 
            camera.updateProjectionMatrix();

            raycaster.setFromCamera(mouse, camera);
            const intersects2 = raycaster.intersectObject(gridPlane);
            if (intersects2.length > 0) {
                const p2 = intersects2[0].point;
                const deltaX = p1.x - p2.x;
                const deltaZ = p1.z - p2.z;
                cameraTarget.x += deltaX;
                cameraTarget.z += deltaZ;

                // RESTRICTION: Clamp camera target to map borders
                const limit = (GRID_SIZE * TILE_SIZE) / 2;
                cameraTarget.x = Math.max(-limit, Math.min(limit, cameraTarget.x));
                cameraTarget.z = Math.max(-limit, Math.min(limit, cameraTarget.z));

                updateCameraPosition();
            }
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            if (isPanning) {
                const dx = event.clientX - lastPanPosition.x;
                const dy = event.clientY - lastPanPosition.y;
                lastPanPosition = { x: event.clientX, y: event.clientY };

                const panSpeed = 6 / camera.zoom; 
                const cos = Math.cos(cameraAngle);
                const sin = Math.sin(cameraAngle);

                cameraTarget.x -= (sin * dx * panSpeed * 0.1) + (cos * dy * panSpeed * 0.1);
                cameraTarget.z -= (-cos * dx * panSpeed * 0.1) + (sin * dy * panSpeed * 0.1);
                
                // RESTRICTION: Clamp panning to map borders
                const limit = (GRID_SIZE * TILE_SIZE) / 2;
                cameraTarget.x = Math.max(-limit, Math.min(limit, cameraTarget.x));
                cameraTarget.z = Math.max(-limit, Math.min(limit, cameraTarget.z));
                
                updateCameraPosition();
                return;
            }

            if (isDragging) {
                const deltaX = event.clientX - previousMousePosition.x;
                cameraAngle += deltaX * 0.005;
                updateCameraPosition();
                previousMousePosition.x = event.clientX;
                previousMousePosition.y = event.clientY;
            }
        }

        function onMouseDown(event) {
            if (event.target.closest('.tool-btn') || 
                event.target.closest('#modal-overlay') || 
                event.target.closest('#selection-menu') || 
                event.target.closest('#minimize-handle') ||
                event.target.closest('#controls-help') ||
                event.target.classList.contains('control-btn')) return;

            // Middle Click Logic (Pan/Rotate)
            if (event.button === 1) {
                event.preventDefault();
                if (event.shiftKey) {
                    isDragging = true;
                    previousMousePosition.x = event.clientX;
                    previousMousePosition.y = event.clientY;
                    document.body.style.cursor = 'ew-resize'; 
                } else {
                    isPanning = true;
                    lastPanPosition = { x: event.clientX, y: event.clientY };
                    document.body.style.cursor = 'move';
                }
                return;
            }

            // Left (0) or Right (2) Click - Context Sensitive Interaction
            if (event.button === 0 || event.button === 2) { 
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(gridPlane);

                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    const x = Math.round(intersect.point.x / TILE_SIZE);
                    const z = Math.round(intersect.point.z / TILE_SIZE);
                    
                    const key = `${x},${z}`;
                    const existing = gameGrid[key];

                    // --- Selection & Interaction Logic ---

                    if (existing) {
                        // 1. Special Interactions (Tower Upgrades / Gold)
                        // Priority Interaction: Tower Upgrade (Shift+Click)
                        if (existing.type === 'tower' && event.shiftKey && event.button === 0) {
                            if (existing.data.level === 1) {
                                if (RESOURCES.gold >= 500) {
                                    RESOURCES.gold -= 500;
                                    existing.data.level = 2;
                                    
                                    // Replace Mesh
                                    scene.remove(existing.mesh);
                                    const newMesh = createVoxelGroup('tower_lvl2');
                                    newMesh.position.copy(existing.mesh.position);
                                    // Removed upgrade bounce animation
                                    // newMesh.scale.set(0.1, 0.1, 0.1);
                                    // new TWEEN_Pop(newMesh.scale, TILE_SIZE/10);
                                    scene.add(newMesh);
                                    existing.mesh = newMesh; // Update ref
                                    existing.type = 'tower_lvl2'; // Update type for visual logic

                                    showToast("Tower Upgraded to Level 2!");
                                    updateUI();
                                    createParticles(x * TILE_SIZE, 10, z * TILE_SIZE, 0xFF0000);
                                    SoundManager.play('build');
                                } else {
                                    showToast("Need 500 Gold to Upgrade Tower.");
                                }
                            } else {
                                showToast("Tower is already max level.");
                            }
                            return;
                        }

                        // Priority Interaction: Tower Gold
                        if (existing.type.includes('tower') && !event.shiftKey && event.button === 0) {
                            // Check if we just selected it, or if we are adding gold
                            if (selectedBuildingKey === key) {
                                // Already selected, maybe just add gold
                            }
                            // Actually, let's allow gold adding always for convenience, 
                            // but ALSO select it.
                            
                            if (RESOURCES.gold >= 5) {
                                RESOURCES.gold -= 5;
                                existing.data.gold += 5;
                                showToast(`Deposited 5 Gold into Tower. (Total: ${existing.data.gold})`);
                                updateUI();
                                createParticles(x * TILE_SIZE, 10, z * TILE_SIZE, 0xFFD700);
                                SoundManager.play('money');
                            } else {
                                showToast("Need 5 Gold to fill tower.");
                            }
                        }

                        // 2. Nature Interaction (Harvest immediately, no menu)
                        if (['tree', 'bush', 'rock'].includes(existing.type)) {
                            removeBuilding(x, z);
                            clearSelection();
                            return;
                        }

                        // 3. Building Selection (Show Menu)
                        if (event.button === 0) {
                            selectedBuildingKey = key;
                            const menu = document.getElementById('selection-menu');
                            menu.classList.add('active');
                            SoundManager.play('ui');
                            
                            // Visual indicator could be added here (highlight mesh)
                            return;
                        }
                        
                        // 4. Right Click (Quick Remove / Debug)
                        if (event.button === 2) {
                            removeBuilding(x, z);
                        }

                    } else {
                        // Tile is Empty: Build
                        // Clear selection first
                        clearSelection();
                        if (event.button === 0) {
                            placeBuilding(x, z, currentTool);
                        }
                    }
                }
            } 
        }

        function onMouseUp(event) {
            if (event.button === 1) {
                isDragging = false;
                isPanning = false;
                document.body.style.cursor = 'default';
            }
        }

        function selectTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`btn-${tool}`).classList.add('active');
            SoundManager.play('ui');
            // clearSelection(); // Optional: clear selection when changing tools?
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const d = 100;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateEconomy() {
            let income = 0;
            let housing = 0;
            let farmCount = 0;
            let lumberCount = 0;
            let mineCount = 0;

            for (let key in gameGrid) {
                const b = gameGrid[key];
                const data = BUILDING_TYPES[b.type];
                // Handle upgraded towers essentially being towers
                if (b.type === 'tower_lvl2') {
                     // No income, just count for completeness if needed
                }
                else if (data) {
                    if (data.income) income += data.income;
                    if (data.tax) income += data.tax;
                    if (data.type === 'residential') housing += data.cap;
                    
                    if (b.type === 'farm') farmCount++;
                    if (b.type === 'lumber') lumberCount++;
                    if (b.type === 'mine') mineCount++;
                }
            }

            RESOURCES.gold += income;
            if (income > 0) SoundManager.play('money');

            // CHANGED: Removed random check (50% chance) so population spawns 100% of the time if capacity exists
            if (RESOURCES.pop < RESOURCES.popCap && RESOURCES.gold > 0) {
                RESOURCES.pop++;
                showToast("Population +1"); 
            }

            while (villagers.length < RESOURCES.pop) {
                villagers.push(new Villager());
            }
            
            const maxFarmers = farmCount * 2; 
            const maxLumberjacks = lumberCount; 
            const maxMiners = mineCount;
            
            let currentFarmers = 0;
            let currentLumberjacks = 0;
            let currentMiners = 0;
            let currentGuards = 0;

            villagers.forEach(v => {
                 if (v.role === 'farmer') currentFarmers++;
                 if (v.role === 'lumberjack') currentLumberjacks++;
                 if (v.role === 'miner') currentMiners++;
                 if (v.role === 'guard') currentGuards++;
            });

            // Only re-assign roles if not a guard (guards are locked in for duration)
            let assignedFarmers = 0;
            let assignedLumber = 0;
            let assignedMiners = 0;
            
            // First pass
            villagers.forEach(v => {
                if (v.role === 'guard') return; 
                
                if (v.role === 'lumberjack') {
                    if (assignedLumber < maxLumberjacks) assignedLumber++;
                    else v.setRole('villager');
                }
                else if (v.role === 'miner') {
                    if (assignedMiners < maxMiners) assignedMiners++;
                    else v.setRole('villager');
                }
                else if (v.role === 'farmer') {
                    if (assignedFarmers < maxFarmers) assignedFarmers++;
                    else v.setRole('villager');
                }
            });

            // CHANGED: Guard Priority Check
            // Before filling resource jobs, calculate how many villagers are needed to fill open tower slots.
            const towers = Object.values(gameGrid).filter(b => b.type.includes('tower'));
            let openGuardSlots = 0;
            towers.forEach(t => {
                if (t.data.gold >= 5 && (t.data.guards || 0) < 5) { 
                    openGuardSlots++; 
                }
            });

            // Second pass
            villagers.forEach(v => {
                if (v.role === 'villager') {
                    // If we need guards, skip assigning this villager to resource jobs.
                    // They will remain 'villager' and pickNewTarget() will assign them to a tower.
                    if (openGuardSlots > 0) {
                        openGuardSlots--;
                        return; 
                    }

                    if (assignedLumber < maxLumberjacks) {
                        v.setRole('lumberjack');
                        assignedLumber++;
                    } else if (assignedMiners < maxMiners) {
                        v.setRole('miner');
                        assignedMiners++;
                    } else if (assignedFarmers < maxFarmers) {
                        v.setRole('farmer');
                        assignedFarmers++;
                    }
                }
            });

            updateUI();
        }

        function updateUI() {
            document.getElementById('res-gold').innerText = RESOURCES.gold;
            document.getElementById('res-wood').innerText = RESOURCES.wood;
            document.getElementById('res-stone').innerText = RESOURCES.stone;
            document.getElementById('res-pop').innerText = `${RESOURCES.pop} / ${RESOURCES.popCap}`;
        }

        function showToast(msg) {
            const container = document.getElementById('notifications');
            const el = document.createElement('div');
            el.className = 'toast';
            el.innerText = msg;
            container.appendChild(el);
            setTimeout(() => el.remove(), 3500);
        }

        const tweens = [];
        function TWEEN_Pop(targetVector, finalScale) {
            this.target = targetVector;
            this.final = finalScale;
            this.progress = 0;
            tweens.push(this);
        }
        TWEEN_Pop.prototype.update = function() {
            this.progress += 0.1;
            const p = this.progress;
            const scale = this.final * (1 + 0.3 * Math.sin(p * Math.PI)); 
            
            if (p >= 1) {
                this.target.set(this.final, this.final, this.final);
                return false; 
            }
            
            this.target.set(scale, scale, scale);
            return true;
        };

        let particles = [];
        function createParticles(x, y, z, color) {
            const geom = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const mat = new THREE.MeshBasicMaterial({ color: color });
            
            for(let i=0; i<8; i++) {
                const mesh = new THREE.Mesh(geom, mat);
                mesh.position.set(x, y, z);
                mesh.vel = {
                    x: (Math.random() - 0.5) * 2,
                    y: Math.random() * 2,
                    z: (Math.random() - 0.5) * 2
                };
                scene.add(mesh);
                particles.push({ mesh: mesh, life: 1.0 });
            }
        }

        function animate(time) {
            requestAnimationFrame(animate);
            if (!scene) return; 
            
            // Pause Logic
            if (isPaused) {
                lastTime = time;
                renderer.render(scene, camera);
                return;
            }

            // Time scaling
            const dt = (time - lastTime) * timeScale;
            lastTime = time;

            updateDayNightCycle(dt);

            // Spawn Invaders at Night
            if (!isDayTime) {
                // 5% chance every second (scaled by speed)
                if (time - invaderSpawnTimer > (2000 / timeScale)) {
                    if (Math.random() < 0.3 && invaders.length < (5 + dayCount * 2)) { // Scale max cap with day (Lowered cap base from 10 to 5)
                        // Scale spawn count with day
                        const baseSpawn = Math.ceil(dayCount / 2);
                        const count = baseSpawn + Math.floor(Math.random() * 2); 
                        
                        for(let i=0; i<count; i++) {
                            invaders.push(new Invader());
                        }
                        showToast(`${count} Invaders approaching!`);
                    }
                    invaderSpawnTimer = time;
                }
            }

            // Entity Updates
            villagers.forEach(v => v.update(dt));
            invaders.forEach(i => i.update(dt));

            // Animations
            const timeSec = time * 0.001;
            for (let key in gameGrid) {
                const b = gameGrid[key];
                
                // Campfire Animation
                if (b.type === 'campfire') {
                    const grp = b.mesh;
                    if (grp.userData.light) {
                        grp.userData.light.intensity = 2.5 + Math.sin(timeSec * 15) * 0.3 + (Math.random() - 0.5) * 0.5;
                    }
                    if (grp.userData.fireParts) {
                        grp.userData.fireParts.forEach((part, idx) => {
                            const pulse = 1 + Math.sin(timeSec * 10 + idx) * 0.15;
                            part.mesh.scale.set(
                                part.baseScale.x * pulse,
                                part.baseScale.y * pulse,
                                part.baseScale.z * pulse
                            );
                        });
                    }
                }

                // Tower Light Animation
                if (b.type === 'tower' || b.type === 'tower_lvl2') {
                    const light = b.mesh.userData.towerLight;
                    if (light) {
                        if (!isDayTime) {
                            light.intensity = 1.0 + Math.sin(timeSec * 2) * 0.2; 
                        } else {
                            light.intensity = 0;
                        }
                    }
                }
            }

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(gridPlane);
            if (intersects.length > 0) {
                const i = intersects[0];
                const x = Math.round(i.point.x / TILE_SIZE) * TILE_SIZE;
                const z = Math.round(i.point.z / TILE_SIZE) * TILE_SIZE;
                placementCursor.position.set(x, 1, z);
                
                const key = `${x/TILE_SIZE},${z/TILE_SIZE}`;
                if (gameGrid[key]) {
                    placementCursor.material.color.setHex(0xff0000); 
                } else {
                    placementCursor.material.color.setHex(0xffffff); 
                }
            }

            if (isGameActive) {
                if (time - economyTimer > 3000) {
                    updateEconomy();
                    economyTimer = time;
                }
                
                // Housing check (Homelessness)
                if (RESOURCES.pop > RESOURCES.popCap) {
                    if (homelessStart === 0) homelessStart = time;
                    if (time - homelessStart > 5000) {
                         // Remove one villager
                         const vIndex = villagers.findIndex(v => v.role === 'villager' && v.state !== 'sleeping'); // Prefer idle villagers
                         if (vIndex !== -1) {
                             villagers[vIndex].remove();
                             villagers.splice(vIndex, 1);
                             RESOURCES.pop--;
                             showToast("A villager left (no housing).");
                         } else if (villagers.length > 0) {
                             // Force remove anyone if no idlers
                             villagers[0].remove();
                             villagers.shift();
                             RESOURCES.pop--;
                             showToast("A villager left (no housing).");
                         }
                         homelessStart = time; // Reset to remove next one in 5s if still over cap
                         updateUI();
                    }
                } else {
                    homelessStart = 0;
                }
                
                if (time - farmerPayTimer > 30000) {
                    if (isDayTime) {
                        const farmerCount = villagers.filter(v => v.role === 'farmer').length;
                        if (farmerCount > 0) {
                            RESOURCES.gold += farmerCount;
                            showToast(`Farmers produced ${farmerCount} Gold`);
                            SoundManager.play('money');
                            updateUI();
                        }
                    }
                    farmerPayTimer = time;
                }

                // Passive Mine Production (Every 20 seconds) - NOW CHECKS FOR DAYTIME
                if (time - minePayTimer > 20000) {
                    if (isDayTime) {
                        const mineCount = Object.values(gameGrid).filter(b => b.type === 'mine').length;
                        if (mineCount > 0) {
                            const produced = mineCount * 5;
                            RESOURCES.stone += produced;
                            showToast(`Mines produced ${produced} Stone`);
                            SoundManager.play('money');
                            updateUI();
                        }
                    }
                    minePayTimer = time;
                }

                // Passive Wood Production (Every 20 seconds) - NOW CHECKS FOR DAYTIME
                if (time - lumberPayTimer > 20000) {
                    if (isDayTime) {
                        const lumberCount = Object.values(gameGrid).filter(b => b.type === 'lumber').length;
                        if (lumberCount > 0) {
                            const produced = lumberCount * 5;
                            RESOURCES.wood += produced;
                            showToast(`Woodcuts produced ${produced} Wood`);
                            SoundManager.play('money');
                            updateUI();
                        }
                    }
                    lumberPayTimer = time;
                }

                // Wages (Every 30 seconds)
                if (time - wageTimer > 30000) {
                    let wages = 0;
                    villagers.forEach(v => {
                        if (v.role === 'lumberjack' || v.role === 'miner') {
                            wages += 1;
                        }
                    });
                    if (wages > 0) {
                        RESOURCES.gold -= wages;
                        if (RESOURCES.gold < 0) RESOURCES.gold = 0; // No debt, just 0
                        showToast(`Paid ${wages} Gold in wages`);
                        SoundManager.play('money');
                        updateUI();
                    }
                    wageTimer = time;
                }
                
                // Nature Spawn Logic
                if (time - natureTimer > 5000) {
                    // Check tree count
                    const treeCount = Object.values(gameGrid).filter(b => b.type === 'tree').length;
                    const spawnChance = treeCount < 2 ? 0.8 : 0.3; // 80% chance if trees are low

                    if (Math.random() < spawnChance) {
                        let rx = Math.floor(Math.random() * GRID_SIZE) - GRID_SIZE/2;
                        let rz = Math.floor(Math.random() * GRID_SIZE) - GRID_SIZE/2;
                        let key = `${rx},${rz}`;
                        
                        if (!gameGrid[key]) {
                            let rand = Math.random();
                            let type = 'bush';
                            
                            if (rand > 0.4) type = 'tree';
                            if (rand > 0.8) type = 'rock';

                            // If tree count is low, force tree spawn more often
                            if (treeCount < 2 && Math.random() > 0.2) type = 'tree';

                            placeBuilding(rx, rz, type, true);
                        }
                    }
                    natureTimer = time;
                }
            }

            for (let i = tweens.length - 1; i >= 0; i--) {
                if (!tweens[i].update()) {
                    tweens.splice(i, 1);
                }
            }

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life -= 0.05;
                p.mesh.position.x += p.mesh.vel.x;
                p.mesh.position.y += p.mesh.vel.y;
                p.mesh.position.z += p.mesh.vel.z;
                p.mesh.rotation.x += 0.1;
                p.mesh.rotation.y += 0.1;
                p.mesh.scale.setScalar(p.life);
                
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        window.onload = init;

    </script>
</body>
</html>